## Лекция 18. Функции. Аргументы

* Функция - блок кода, к которому можно обращаться по мере необходимости.
* Функции бывают: явные и неявные.
* Функции в Python по умолчанию возвращают `None`

### 0. Вызов и сигнатура
* Сигнатура функции - это блок-определения функции.
* Вызов функции осуществляется ТОЛЬКО после определения самой функции.
* `func_name(...)` - знак интерпретатору, что `func_name` - это т.н. вызываемый объект!
* Замена значения у функционального объекта:
```
def hello():
    print("Hello!")

hello = 10
hello() # здесь буквально написано `10()` - ошибка
```
* Присваивание функционального объекта:
```
def hello():
    print("Hello!")

new_name = hello
print(hello)

new_name()
```


### 1. Аргументы. Необх. позициональные
* `Required Postitional Args` - это аргументы, которые всегда необходимо передавать в том же количестве, в каком они указаны в сигнатуре функции! Более того - порядок передачи аргументов ВАЖЕН для корректной работы функции.

* Пример:
```
def sub_squared(a, b):
    res = a ** 2 - 2*a*b - b ** 2
    return res

print(sub_squared(3,4)) # Здесь будет один ответ
print(sub_squared(4,3)) # Здесь другой
```
В этом выражается позициональность - важен порядок указания аргументов.

* Необходимость:
```
def sub_squared(a, b):
    res = a ** 2 - 2*a*b - b ** 2
    return res

print(sub_squared(3)) # Не работает - не хватает аргумента b
print(sub_squared(4,3))
print(sub_squared(10, 10, 10)) # Не работает - слишком много аргументов
```

* Определение функций "верхнего" и "нижнего" уровней:
```
def print_factorials(start, stop):
    for j in range(start, stop + 1):
        print(f"{j}! = {factorial(j)}")

def factorial(n):
    if n < 0:
        return None
    if n <= 1:
        return 1
    res = 1
    for i in range(2, n+1):
        res *= i
    return res


print_factorials(1, 15)

```
Смсыл в том, что функции нижнего уровня (`factorial`) могут быть определены ГДЕ УГОДНО, главное только чтобы их определение встретилось ДО МОМЕНТА ВЫЗОВА функции верхнего уровня (`print_factorial`)


### X. Зачем использоваться функции?
* Смысл использования функций заключается в локализации какого-то блока кода и постепенному обращению к этому блоку.
* Если вы допустили ошибку в функции - вам достаточно лишь исправить ошибку в ОДНОМ МЕСТЕ!
* Функции позволяют `декопмозировать` код - разбить полотно на набор независимых друг от друга участков кода и работать над ними по отдельности!